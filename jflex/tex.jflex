/* template ver 1.1.0 */
package nodamushi.hl.analysis.parser.flex;
import nodamushi.hl.analysis.Token;
import nodamushi.hl.analysis.parser.AutoGeneratedParser;

%%

/* write this class name! */
%class TeXFlexParser
%implements AutoGeneratedParser
%unicode
%char
%line
%function _parse
%type void
%public


%{


    public static final int LINEMATH=1000,
	BEGINMATH=1001,ENDMATH=1002;
  /* write this class name! this method is a constructor */
  public TeXFlexParser(String str){
    this(new java.io.StringReader(str));
    this.originalSource = str;
  }

  private String originalSource;

  private java.util.ArrayList<Token> tokens = new java.util.ArrayList<>();

  @Override
  public java.util.Collection<Token> parse(){
    tokens.clear();
    try{
        _parse();
    }catch(Exception e){e.printStackTrace();}
    return tokens;
  }


  private void push(Token t){
    if(t!=null)
      tokens.add(t);
  }
  private Token token(int type){
    return token(type,yychar,yylength());
  }

  private Token token(int type,int xchar,int length){
    return new Token(type,xchar,length,yyline,originalSource);
  }
  
  /*
    use this method when token's end position can't be find at one iteration
  */
  private int tokenStartPosition=0;
  private int tokenLength=0;
  private boolean nowLong=false;
  //yychar of begining of line
  private int bol=0;
  private int homeposition=0;
  private java.util.ArrayList<Integer> firstTimeFlag=new java.util.ArrayList<>(16);

  private void longTokenInit(){
    tokenStartPosition = yychar;
    tokenLength=0;
    nowLong=true;
  }
  //set begining of line
  private void setBOL(){
    homeposition = yychar + yylength();
    firstTimeFlag.clear();
  }

  //is  begining of line
  private boolean isBOL(){
    return yychar == homeposition;
  }

  
  private boolean isFirstTimeInLine(int type){
    boolean b = firstTimeFlag.contains(type);
    if(!b)firstTimeFlag.add(type);
    return b;
  }

  private void longTokenInit_by_NewLine(){
    tokenStartPosition = yychar+yylength();
    tokenLength=0;
    nowLong=true;
  }
  
  private void addLongToken(){
    tokenLength += yylength();
  }
  
  private Token longToken(int type){
    nowLong=false;
    if(tokenLength==0)return null;
    return token(type,tokenStartPosition,tokenLength);
  }

%}


%eofval{
  return;
%eofval}

LineTerminator =\r|\n|\r\n
InputCharacter =[^\r\n\\ \t\f%{}$]+
WhiteSpace = [ \t\f]+



/* identifier */
Identifier=\\[@a-zA-Z]+


/* branch */
BranchSymbol=\\fi|\\else|\\if|\\ifmode|\\ifx|\\iftrue|\\iffalse|\\ifnum
							  

/* define or declare something.exp. define,function,var,  */
DefineSymbol=\\newcommand|\\def|\\edef|\\newcount|\\newcounter


%%


<YYINITIAL>{
  {BranchSymbol}	{push(token(BRANCH_TOKEN));return;}
  {DefineSymbol}	{push(token(DEFINE_TOKEN));return;}
  {LineTerminator}	{push(token(NEWLINE_TOKEN));setBOL();return;}
  {WhiteSpace}		{push(token(SPACE_TOKEN));return;}
  "\\\\"|"\\"[{},#%!\$]
  	{push(token(IDENTIFIER));return;}
  
  \{|\}			{push(token(BLOCK_TOKEN));return;}
  \[|\]			{push(token(PARENTHESIS_TOKEN));return;}
  "$"			{push(token(LINEMATH));return;}
  "\\["|"\\begin{eqnarray}"|"\\begin{eqnarray*}"
  {push(token(BEGINMATH));return;}
  "\\]"|"\\end{eqnarray}"|"\end{eqnarray*}"
  {push(token(ENDMATH));return;}
  
  "%"[^\r\n]*		{push(token(COMMENT_TOKEN));return;}
  {Identifier}|#[1-9]	{push(token(IDENTIFIER));return;}
  {InputCharacter}	{push(token(TEXT));return;}
  .			{push(token(TEXT));return;}
			 
}


/* error fallback */
  .|\n                             {
    System.err.println("jflex parser  error: state "+yystate()+";\n    char("+yychar
      +") line("+yyline+") string: "+yytext());yybegin(YYINITIAL);push(token(UNKNOWN));return; }

