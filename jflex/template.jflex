/* template ver 1.1.0 */
package nodamushi.hl.analysis.parser.flex;
import nodamushi.hl.analysis.Token;
import nodamushi.hl.analysis.parser.AutoGeneratedParser;

%%

/* write this class name! */
%class FlexParser
%implements AutoGeneratedParser
%unicode
%char
%line
%function _parse
%type void
%public


%{
  /* write this class name! this method is a constructor */
  public FlexParser(String str){
    this(new java.io.StringReader(str));
    this.originalSource = str;
  }

  private String originalSource;

  private java.util.ArrayList<Token> tokens = new java.util.ArrayList<>();

  @Override
  public java.util.Collection<Token> parse(){
    tokens.clear();
    try{
        _parse();
    }catch(Exception e){e.printStackTrace();}
    return tokens;
  }


  private void push(Token t){
    if(t!=null)
      tokens.add(t);
  }
  private Token token(int type){
    return token(type,yychar,yylength());
  }

  private Token token(int type,int xchar,int length){
    return new Token(type,xchar,length,yyline,originalSource);
  }
  
  /*
    use this method when token's end position can't be find at one iteration
  */
  private int tokenStartPosition=0;
  private int tokenLength=0;
  private boolean nowLong=false;

  private void longTokenInit(){
    tokenStartPosition = yychar;
    tokenLength=0;
    nowLong=true;
  }

  private void longTokenInit_by_NewLine(){
    tokenStartPosition = yychar+yylength();
    tokenLength=0;
    nowLong=true;
  }
  
  private void addLongToken(){
    tokenLength += yylength();
  }
  
  private Token longToken(int type){
    nowLong=false;
    if(tokenLength==0)return null;
    return token(type,tokenStartPosition,tokenLength);
  }

%}


%eofval{
  if(nowLong){
    switch(yystate()){
    case STRING:
      push(longToken(STRING_TOKEN));
      break;
    case COMMENTS:
      push(longToken(COMMENT_TOKEN));
      break;
    }
  }
  return;
%eofval}

LineTerminator =\r|\n|\r\n
InputCharacter =[^\r\n]
WhiteSpace = [ \t\f]+



/* identifier */
Identifier=

/* plain-token  */
PlainSymbol = ,|:

/* operator */
EqOperatorSymbol= \+|-|\*|\/|\%|\!|\<|\>|\=|&|\||\^|&&|\|\||\>\>|\>\>\>|\<\<|\~
  OperatorSymbol = {EqOperatorSymbol}\=|{EqOperatorSymbol}|\+\+|--|\?


/* branch */
BranchSymbol=for|while|do|continue|break|if|switch|else|case|default
							  
/* Type of variables. exp. int,short,..   */
TypeSymbol=

/* end of a sentence.like ";" */
EOS=

/* comments */
CommentStart=
CommentEnd  =

/* define or declare something.exp. define,function,var,  */
DefineSymbol=

/* string */
BeginString=
EndString =

/* access operator.exp. ".","->"  */
ACCESS = \.

/* return  */
ReturnSymbol =return

/* number */
NumberLiteral = [0-9]+\.[0-9]*|[0-9]*\.[0-9]+



%state STRING
%state COMMENTS

%%


<YYINITIAL>{
  {BranchSymbol}	{push(token(BRANCH_TOKEN));return;}
  {TypeSymbol}		{push(token(TYPE_TOKEN));return;}
  {ReturnSymbol}	{push(token(RETURN_TOKEN));return;}
  {DefineSymbol}	{push(token(DEFINE_TOKEN));return;}
  {OperatorSymbol}	{push(token(OPERATOR_TOKEN));return;}
  {EOS}			{push(token(EOS_TOKEN));return;}
  {NumberLiteral}	{push(token(NUMBER_TOKEN));return;}
  {LineTerminator}	{push(token(NEWLINE_TOKEN));return;}
  {WhiteSpace}		{push(token(SPACE_TOKEN));return;}
  {ACCESS}		{push(token(ACCESS_TOKEN));return;}
  {BeginString}		{longTokenInit();addLongToken();yybegin(STRING);}
  {CommentStart}	{longTokenInit();addLongToken();yybegin(COMMENTS);}

  \{|\}			{push(token(BLOCK_TOKEN));return;}
  \(|\)|\[|\]		{push(token(PARENTHESIS_TOKEN));return;}
  {PlainSymbol}		{push(token(PLAIN_TOKEN));return;}
  

  {Identifier}		{push(token(IDENTIFIER));return;}



  /* error? */
  .			{push(token(UNKNOWN);return;}
}


<STRING>{
  /* 
    \\\\		{addLongToken();}
    \\\"|[^\n\r\"\\]+	{addLongToken();}
    \\			{addLongToken();}
  */


  {LineTerminator}	{
    push(longToken(STRING_TOKEN));
    push(token(NEWLINE_TOKEN));
    longTokenInit_by_NewLine();
    return;
  }


  {EndString}		{yybegin(YYINITIAL);addLongToken();push(longToken(STRING_TOKEN));return;}

  /* 
    .			{addLongToken();}
   */

}


<COMMENTS>{

  /*      
     [^\n\r]+		{addLongToken();}
   */
  
  {LineTerminator}	{
    push(longToken(COMMENT_TOKEN));
    push(token(NEWLINE_TOKEN));
    longTokenInit_by_NewLine();
    return;
  }


  {CommentEnd}		{yybegin(YYINITIAL);addLongToken();push(longToken(COMMENT_TOKEN));return;}

  /*
    .			{addLongToken();}
   */
}

/* error fallback */
  .|\n                             {
    System.err.println("jflex parser  error: state "+yystate()+";\n    char("+yychar
      +") line("+yyline+") string: "+yytext());yybegin(YYINITIAL);push(token(UNKNOWN));return; }

