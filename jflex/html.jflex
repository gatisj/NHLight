/* template ver 1.1.0 */
package nodamushi.hl.analysis.parser.flex;
import nodamushi.hl.analysis.Token;
import nodamushi.hl.analysis.parser.AutoGeneratedParser;

%%

/* write class name */
%class HTMLFlexParser
%implements AutoGeneratedParser
%unicode
%char
%line
%function _parse
%type void
%public


%{
  /** "=" in tag */
  public static final int
    EQUAL_TOKEN=10000;
  /** attribute value  */
  public static final int
    ATTRIBUTE_VALUE_TOKEN=10001;
  /** &lt;/ */
  public static final int
    CLOSETAG_BEGIN_TOKEN=10002;
  /** $lt;/..."&gt;" */
  public static final int
    CLOSETAG_END_TOKEN=10003;
  /** &lt; */
  public static final int
    TAG_BEGIN_TOKEN=10004;
  /** &gt; */
  public static final int
    TAG_END_TOKEN=10005;
  /** &lt;.../&gt; */
  public static final int
    SINGLETAG_BEGIN_TOKEN=10006;
  /**&lt;.../&gt; */
  public static final int
    SINGLETAG_END_TOKEN=10007;
  /** attribute name */
  public static final int
    ATTRIBUTE_NAME_TOKEN=MARKUP_TAG_ATTRIBUTE_TOKEN;
  /** tag name */
  public static final int
    TAGNAME_TOKEN=MARKUP_TAG_NAME_TOKEN;
  /** contents of &lt;script&gt;>*/
  public static final int
    SCRIPT_CONTENTS=-10030;
  /** : for XHTML */
  public static final int
    COLON_TOKEN=10040;

  public static final int
    MARKUP_DECLARATION_TOKEN=-10060;
  public static final int
    MARKUP_DECLARATION_BEGIN_TOKEN=10060;
  public static final int
    MARKUP_DECLARATION_END_TOKEN=10070;



  private static final int
    TAGBEGIN_IMP=1000;
  private static final int
    TAGEND_IMP=1001;

  

  public HTMLFlexParser(String str){
    this(new java.io.StringReader(str));
    this.originalSource = str;
  }

  private String originalSource;

  private java.util.ArrayList<Token> tokens = new java.util.ArrayList<>();

  @Override
  public java.util.Collection<Token> parse(){
    tokens.clear();
    try{
        _parse();
    }catch(Exception e){e.printStackTrace();}
    return tokens;
  }


  private void push(Token t){
    if(t!=null)
      tokens.add(t);
  }
  private Token token(int type){
    return token(type,yychar,yylength());
  }

  private Token token(int type,int xchar,int length){
    return type==SCRIPT_CONTENTS? new Token(type,xchar,length,-1,originalSource): new Token(type,xchar,length,yyline,originalSource);
  }
  

  private int tokenStartPosition=0;
  private int tokenLength=0;
  private boolean nowLong=false;

  private void longTokenInit(){
    tokenStartPosition = yychar;
    tokenLength=0;
    nowLong=true;
  }

  private void longTokenInit_by_NewLine(){
    tokenStartPosition = yychar+yylength();
    tokenLength=0;
    nowLong=true;
  }
  
  private void addLongToken(){
    tokenLength += yylength();
  }
  
  private Token longToken(int type){
    nowLong=false;
    if(tokenLength==0)return null;
    return token(type,tokenStartPosition,tokenLength);
  }




  private int startLTyychar=-1;// value of yycahr when "<" appeard 
  private String tagName=null;
  private boolean findTagName=false;// whether tag name is find 
  private boolean tagFlag=false;// mean "base state is TAG".used in STRING state
  private boolean findEqual=false;// if before token is "=",this flag is true.
  private int tagType = 0;//0:<tag> 1:</tag> 2:<tag/>
  private boolean scriptFlag = false;//mean "base state is SCRIPT".
  //  private boolean doReturn=false;
  
  private Token tagIdentifierToken(){
    if(findEqual){
      findEqual=false;
      return token(ATTRIBUTE_VALUE_TOKEN);
    }
    findEqual=false;
    if(findTagName){
      return token(ATTRIBUTE_NAME_TOKEN);
    }else{
      findTagName = true;
      tagName = yytext();
      return token(TAGNAME_TOKEN);
    }
  }

  // find <
  private void makeTagFlag(int type){
    startLTyychar = yychar;
    findTagName=false;
    tagName = null;
    tagFlag = true;
    findEqual = false;
    //    doReturn=false;
    tagType = type;
    yybegin(TAG);
    push(token(TAGBEGIN_IMP));
  }

  // find =
  private Token eqToken(){
    findEqual = true;
    return token(PLAIN_TOKEN);
  }
  // find "/>"
  private void findSingleTag(){
    if(tagType==1)mistakeTag();
    else{
      tagType=2;
      push(token(SINGLETAG_END_TOKEN));
      finishTag();
    }
  }

  // find ">"
  private void finishTag(){
    if(findTagName){
      if(scriptFlag && (tagType!=1 || !"script".equals(tagName.toLowerCase()))){
	mistakeTag();
      }else{
	for(Token t:tokens){
	  int type = t.getType();
	  switch(tagType){
	  case 0:
	    if(type==TAGBEGIN_IMP)
	      t.setType(TAG_BEGIN_TOKEN);
	    else if(type==TAGEND_IMP)
	      t.setType(TAG_END_TOKEN);
	    break;
	    
	  case 1:
	    if(type==TAGBEGIN_IMP)
	      t.setType(CLOSETAG_BEGIN_TOKEN);
	    else if(type==TAGEND_IMP)
	      t.setType(CLOSETAG_END_TOKEN);
	    
	    break;
	    
	  case 2:
	    if(type==TAGBEGIN_IMP)
	      t.setType(SINGLETAG_BEGIN_TOKEN);
	    else if(type==TAGEND_IMP)
	      t.setType(SINGLETAG_END_TOKEN);

	    break;
	  }//end switch
	}//end for
	
	switch(tagType){
	case 0:
	  if("script".equals(tagName.toLowerCase())){
	    scriptFlag=true;
	    yybegin(SCRIPT);
	  }else yybegin(YYINITIAL);
	  break;
	  
	case 1:
	  scriptFlag=false;
	  yybegin(YYINITIAL);
	  break;

	case 2:
	  yybegin(YYINITIAL);
	  break;
	}//end switch
	_finishTag();
      }//end else
    }else mistakeTag();// parser don't know tagname
  }
  

  // "<" is not tag
  private void mistakeTag(){
    push(token(0));
    convertBufferTokens();
    _finishTag();
    if(scriptFlag)yybegin(SCRIPT);
    else yybegin(YYINITIAL);
  }

  // postprocess
  private void _finishTag(){
     startLTyychar=-1;
    findTagName = false;
    tagFlag=false;
  }

  //convert tokens to "TEXT" or "SCRIPT_CONTENTS"
  private void convertBufferTokens(){
    int setType = scriptFlag?SCRIPT_CONTENTS:TEXT;
    for(Token t:tokens){
      //when state is script,newline tokens are converted to script contents tokens too.
      if(scriptFlag || t.getType()!=NEWLINE_TOKEN){
	t.setType(setType);
      }
    }
  }




  //for String state

  private int stringType;
  private int stringBaseState;



  
%}


%eofval{
  if(nowLong){
    switch(yystate()){
    case STRINGs:
    case STRINGd:
      push(longToken(stringType));
      break;
    case COMMENTS:
      push(longToken(COMMENT_TOKEN));
      break;
    }
  }
  return;
%eofval}

LineTerminator =\r|\n|\r\n
InputCharacter =[^\r\n]
WhiteSpace = [ \t\f]
Tagname = [a-zA-Z0-9_\-]+



Identifier=[a-zA-Z0-9_\-]+

/* markup declaration */
MarkupDeclaration="<!"

/* comment */
/* 複数行 */
CommentStart="<!--"
CommentEnd  ="-->"



/* 文字列 */
EndStringD =\"
EndStringS =\'



%state STRINGd
%state STRINGs
%state COMMENTS
%state MARKUPDECLARATION
%state TAG
%state SCRIPT


%%


<YYINITIAL>{

  {LineTerminator}	{push(token(NEWLINE_TOKEN));return;}

  {CommentStart}	{longTokenInit();addLongToken();yybegin(COMMENTS);}
  
  {MarkupDeclaration}	{yybegin(MARKUPDECLARATION);push(token(MARKUP_DECLARATION_BEGIN_TOKEN));return;}

  [^<\r\n]+		{push(token(TEXT));return;}
  
  "<"{WhiteSpace}*"/"	{makeTagFlag(1);}/* set state TAG */
  "<"			{makeTagFlag(0);}/* set state TAG */

}
<SCRIPT>{
  "<"{WhiteSpace}*"/"		{makeTagFlag(1);}

  \"			{longTokenInit();addLongToken();yybegin(STRINGd);
			 stringType=SCRIPT_CONTENTS;stringBaseState=SCRIPT;}
  \'			{longTokenInit();addLongToken();yybegin(STRINGs);
			 stringType=SCRIPT_CONTENTS;stringBaseState=SCRIPT;}


  
  
  [^<]+			{push(token(SCRIPT_CONTENTS));return;}
  "<"			{push(token(SCRIPT_CONTENTS));return;}
  
}


<TAG>{
  {WhiteSpace}+		{push(token(SPACE_TOKEN));}
  {Identifier}			{push(tagIdentifierToken());}
  "="			{push(eqToken());}
  :			{push(token(COLON_TOKEN));}
  \"			{longTokenInit();addLongToken();yybegin(STRINGd);
			 findEqual=false;stringType=STRING_TOKEN;stringBaseState=TAG;}
  \'			{longTokenInit();addLongToken();yybegin(STRINGs);
			 findEqual=false;stringType=STRING_TOKEN;stringBaseState=TAG;}


  "/"{WhiteSpace}*">"	{
    findSingleTag();
    //    if(doReturn){doReturn=false;return;}
    return;
  }

  ">"			{
    push(token(tagType==0?
	       TAG_END_TOKEN:
	       CLOSETAG_END_TOKEN));
    finishTag();
    //    if(doReturn){doReturn=false;return;}
    return;
  }
}


<STRINGd>{

    \\\\		{addLongToken();}
    \\\"|[^\n\r\"\\]+	{addLongToken();}
    \\			{addLongToken();}



  {LineTerminator}	{
    if(!scriptFlag){
      push(longToken(stringType));
      push(token(NEWLINE_TOKEN));
      longTokenInit_by_NewLine();
    }else{//script contents
      addLongToken();
    }
  }


  {EndStringD}		{
    addLongToken();
    yybegin(stringBaseState);
    push(longToken(stringType));
  }
}

<STRINGs>{

    \\\\		{addLongToken();}
    \\\'|[^\n\r\'\\]+	{addLongToken();}
    \\			{addLongToken();}



  {LineTerminator}	{
    if(!scriptFlag){
      push(longToken(stringType));
      push(token(NEWLINE_TOKEN));
      longTokenInit_by_NewLine();
    }else{//script contents
      addLongToken();
    }
  }


  {EndStringS}		{
    addLongToken();
    yybegin(stringBaseState);
    push(longToken(stringType));
  }
}



<COMMENTS>{

  [^\n\r>\-]+		{addLongToken();}
  
  {LineTerminator}	{
    push(longToken(COMMENT_TOKEN));
    push(token(NEWLINE_TOKEN));
    longTokenInit_by_NewLine();
    return;
  }


  {CommentEnd}		{yybegin(YYINITIAL);addLongToken();push(longToken(COMMENT_TOKEN));return;}


  ">"|"-"		{addLongToken();}

}

<MARKUPDECLARATION>{

  [^\n\r>\"\']+		{push(token(MARKUP_DECLARATION_TOKEN));return;}
  
  {LineTerminator}	{
    push(token(MARKUP_DECLARATION_TOKEN));
    push(token(NEWLINE_TOKEN));
    return;
  }

  \"			{longTokenInit();addLongToken();yybegin(STRINGd);
			 stringType=MARKUP_DECLARATION_TOKEN;stringBaseState=MARKUPDECLARATION;}
  \'			{longTokenInit();addLongToken();yybegin(STRINGs);
			 stringType=MARKUP_DECLARATION_TOKEN;stringBaseState=MARKUPDECLARATION;}



  ">"		{yybegin(YYINITIAL);push(token(MARKUP_DECLARATION_END_TOKEN));return;}


}

/* error fallback */
.|\n                             { System.err.println("token error:char("+yychar+") string: "+yytext());yybegin(YYINITIAL);push(token(TEXT));return; }

